<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Orbital Playground ‚Äî Surpresa</title>
<style>
  :root{
    --bg:#07060b;
    --panel: rgba(255,255,255,0.03);
    --glass: rgba(255,255,255,0.04);
  }
  html,body{height:100%;margin:0;background:radial-gradient(1200px 600px at 10% 10%, #0b0a12 0%, var(--bg) 40%), linear-gradient(180deg,#06050a,#0a0710);font-family:Inter,system-ui,Segoe UI,Arial; color:#fff; -webkit-font-smoothing:antialiased;}
  .wrap{height:100vh;display:flex;align-items:center;justify-content:center;padding:28px;box-sizing:border-box;}
  .shell{
    width:min(1100px,96vw);
    aspect-ratio:16/9;
    border-radius:18px;
    overflow:hidden;
    position:relative;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.12));
    box-shadow: 0 18px 60px rgba(0,0,0,0.7), inset 0 1px 0 rgba(255,255,255,0.02);
  }

  canvas{width:100%;height:100%;display:block;touch-action:none}

  .topbar{
    position:absolute;left:18px;top:14px;display:flex;gap:10px;align-items:center;z-index:6;
  }
  .dot{width:12px;height:12px;border-radius:50%;background:linear-gradient(180deg,#ff6fa8,#ff2ea6);box-shadow:0 6px 18px rgba(255,46,166,0.22)}
  .title{font-weight:700;font-size:13px;color:rgba(255,255,255,0.92);padding:8px 12px;border-radius:10px;background:var(--panel);backdrop-filter:blur(6px)}
  .controls{position:absolute;right:18px;top:14px;display:flex;gap:8px;align-items:center;z-index:6}
  .btn{font-size:13px;padding:8px 10px;border-radius:10px;background:var(--glass);border:1px solid rgba(255,255,255,0.02);cursor:pointer;color:rgba(255,255,255,0.9)}
  .hint{position:absolute;left:18px;bottom:18px;font-size:13px;padding:8px 10px;border-radius:10px;background:var(--panel);z-index:6}
  .legend{position:absolute;right:18px;bottom:18px;font-size:12px;padding:8px 10px;border-radius:10px;background:var(--panel);z-index:6;color:rgba(255,255,255,0.85)}

  /* small responsive */
  @media (max-width:640px){
    .title{font-size:12px;padding:6px 8px}
    .btn{padding:6px 8px;font-size:12px}
    .hint{font-size:12px}
    .legend{font-size:11px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="shell" id="shell">
      <div class="topbar">
        <div class="dot"></div>
        <div class="title">orbital playground</div>
      </div>
      <div class="controls">
        <button class="btn" id="add">‚ûï adicionar corpo</button>
        <button class="btn" id="clear">üßπ limpar</button>
        <button class="btn" id="sound">üîä som: ligado</button>
      </div>
      <canvas id="c"></canvas>
      <div class="hint">Clique/arraste para criar ou empurrar. Duplo clique para congelar</div>
      <div class="legend">Toque/Mouse ‚ú¶ Gravidade real√≠stica ‚ú¶ Trilhas</div>
    </div>
  </div>

<script>
/* Orbital Playground
   - Um sistema f√≠sico estilo "mini-universo": corpos com massa, √≥rbitas, colis√£o el√°stica aproximada.
   - Intera√ß√£o: clique para empurrar, arraste para lan√ßar, bot√£o para adicionar corpos, som reativo.
   - Tudo embutido em um √∫nico arquivo, sem bibliotecas externas.
*/

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: true });
let DPR = Math.min(2, window.devicePixelRatio || 1);

function fitCanvas(){
  DPR = Math.min(2, window.devicePixelRatio || 1);
  const r = canvas.getBoundingClientRect();
  canvas.width = Math.floor(r.width*DPR);
  canvas.height = Math.floor(r.height*DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', fitCanvas, {passive:true});
fitCanvas();

// ---------- Physics ----------
const G = 2200; // gravity constant (tune)
const bodies = []; // {x,y,vx,vy,mass,r,color,trail:[]}
let trailsEnabled = true;
let running = true;

function rand(min,max){return min + Math.random()*(max-min);}
function hueColor(h,s=85,l=60,a=1){ return `hsla(${h},${s}%,${l}%,${a})`; }

// create random body
function createBody(x,y,mass,hue){
  const r = Math.max(6, Math.sqrt(mass)*2.6);
  const b = {
    x,y,
    vx: rand(-40,40),
    vy: rand(-40,40),
    mass,
    r,
    hue,
    color: hueColor(hue,92,55,1),
    trail: []
  };
  bodies.push(b);
  return b;
}

// initial demo bodies (planets + central star)
function seedDemo(){
  bodies.length = 0;
  const W = canvas.width/DPR, H = canvas.height/DPR;
  // central massive object
  createBody(W*0.5, H*0.5, 4200, rand(280,340)).vx = 0; // big slow
  // orbiting planets
  for(let i=0;i<6;i++){
    const ang = i/6*Math.PI*2 + 0.3;
    const dist = 90 + i*60 + rand(-8,8);
    const x = W*0.5 + Math.cos(ang)*dist;
    const y = H*0.5 + Math.sin(ang)*dist;
    const mass = rand(60,460);
    const b = createBody(x,y,mass, rand(200,360));
    // set near-circular velocity
    const dx = x - W*0.5, dy = y - H*0.5;
    const distSq = Math.max(16, dx*dx+dy*dy);
    const speed = Math.sqrt(G * bodies[0].mass / distSq);
    const dir = Math.atan2(dy,dx) + Math.PI/2;
    b.vx = Math.cos(dir)*speed + rand(-6,6);
    b.vy = Math.sin(dir)*speed + rand(-6,6);
  }
}
seedDemo();

// physics step
function step(dt){
  if(!running) return;
  const n = bodies.length;
  // pairwise gravity
  for(let i=0;i<n;i++){
    const A = bodies[i];
    for(let j=i+1;j<n;j++){
      const B = bodies[j];
      const dx = B.x - A.x;
      const dy = B.y - A.y;
      const dist2 = dx*dx + dy*dy;
      const dist = Math.sqrt(dist2) + 0.0001;
      const f = (G * A.mass * B.mass) / (dist2 + (A.r+B.r)*(A.r+B.r)*0.6);
      const ax = (f / A.mass) * (dx / dist);
      const bx = (f / B.mass) * (-dx / dist);
      const ay = (f / A.mass) * (dy / dist);
      const by = (f / B.mass) * (-dy / dist);
      A.vx += ax * dt;
      A.vy += ay * dt;
      B.vx += bx * dt;
      B.vy += by * dt;

      // simple collision - merge small into big (inelastic-ish)
      if(dist < (A.r + B.r) * 0.92){
        // keep center of mass
        const big = (A.mass >= B.mass) ? A : B;
        const small = (big === A) ? B : A;
        const totalM = big.mass + small.mass;
        big.vx = (big.vx*big.mass + small.vx*small.mass)/totalM;
        big.vy = (big.vy*big.mass + small.vy*small.mass)/totalM;
        big.mass = totalM;
        big.r = Math.max(6, Math.sqrt(big.mass)*2.6);
        // absorb color hue average
        big.hue = (big.hue * big.mass + small.hue * small.mass) / totalM;
        // remove small
        const idx = bodies.indexOf(small);
        if(idx >= 0) bodies.splice(idx,1);
      }
    }
  }

  // integrate
  for(const b of bodies){
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    // friction tiny
    b.vx *= 0.9999;
    b.vy *= 0.9999;
    // trails
    if(trailsEnabled){
      b.trail.push({x:b.x,y:b.y,a:1});
      if(b.trail.length > 80) b.trail.shift();
      // fade
      for(const t of b.trail) t.a -= 0.01*dt*60;
    } else b.trail = [];
  }
}

// ---------- Rendering ----------
function render(){
  const W = canvas.width/DPR, H = canvas.height/DPR;
  // background
  ctx.clearRect(0,0,W,H);
  // subtle noise gradient
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'rgba(0,0,0,0.18)');
  g.addColorStop(1,'rgba(6,4,10,0.2)');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // starfield
  drawStars(W,H);

  // glow for each body (back to front)
  for(const b of bodies){
    const glow = Math.min(1, Math.log10(b.mass+20)/3);
    const rg = ctx.createRadialGradient(b.x,b.y,b.r*0.2,b.x,b.y,b.r*6);
    rg.addColorStop(0, `hsla(${b.hue},95%,62%,${0.18*glow})`);
    rg.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = rg;
    ctx.fillRect(b.x-b.r*6, b.y-b.r*6, b.r*12, b.r*12);
  }

  // trails
  for(const b of bodies){
    if(b.trail.length > 2){
      ctx.beginPath();
      for(let i=0;i<b.trail.length-1;i++){
        const p = b.trail[i], q = b.trail[i+1];
        ctx.moveTo(p.x,p.y);
        ctx.lineTo(q.x,q.y);
      }
      ctx.strokeStyle = `hsla(${b.hue},95%,60%,0.14)`;
      ctx.lineWidth = Math.max(1, Math.log2(b.r)*0.9);
      ctx.lineCap = 'round';
      ctx.stroke();
    }
  }

  // bodies (front)
  // sort by radius for painter's order
  const sorted = bodies.slice().sort((a,b)=>a.r - b.r);
  for(const b of sorted){
    // ring
    ctx.beginPath();
    ctx.arc(b.x,b.y,b.r*1.2,0,Math.PI*2);
    ctx.fillStyle = `rgba(255,255,255,0.02)`;
    ctx.fill();

    // core
    ctx.beginPath();
    ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
    // radial gradient core
    const cg = ctx.createRadialGradient(b.x - b.r*0.3, b.y - b.r*0.3, b.r*0.1, b.x, b.y, b.r);
    cg.addColorStop(0, `hsla(${b.hue},100%,72%,1)`);
    cg.addColorStop(0.55, `hsla(${(b.hue+30)%360},95%,48%,0.95)`);
    cg.addColorStop(1, `rgba(0,0,0,0.06)`);
    ctx.fillStyle = cg;
    ctx.fill();

    // tiny specular
    ctx.beginPath();
    ctx.ellipse(b.x - b.r*0.35, b.y - b.r*0.45, b.r*0.35, b.r*0.55, -0.7, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fill();
  }
}

// starfield cache
let stars = [];
function makeStars(W,H){
  stars = [];
  const count = Math.round((W*H)/12000);
  for(let i=0;i<count;i++){
    stars.push({
      x: Math.random()*W,
      y: Math.random()*H,
      r: Math.random()*1.4+0.2,
      a: rand(0.08,0.8),
      hue: rand(200,340)
    });
  }
}
function drawStars(W,H){
  if(!stars.length || stars.length < Math.round((W*H)/12000)) makeStars(W,H);
  for(const s of stars){
    ctx.beginPath();
    ctx.arc(s.x,s.y,s.r,0,Math.PI*2);
    ctx.fillStyle = `hsla(${s.hue},80%,80%,${s.a*0.9})`;
    ctx.fill();
  }
}

// ---------- Interaction ----------
let pointer = {x:0,y:0,down:false,dx:0,dy:0,downStart:null};
canvas.addEventListener('pointerdown', (e)=>{
  const r = canvas.getBoundingClientRect();
  pointer.x = (e.clientX - r.left);
  pointer.y = (e.clientY - r.top);
  pointer.down = true;
  pointer.dx = 0; pointer.dy = 0;
  pointer.downStart = {x:pointer.x,y:pointer.y,t:performance.now()};
  // if clicked on body, pick it
  pick = pickBody(pointer.x,pointer.y);
  // small push
  if(!pick){
    // create small projectile-like body where clicked
    const mass = rand(24,120);
    const b = createBody(pointer.x, pointer.y, mass, rand(200,360));
    // soft impulse away from center
    const W = canvas.width/DPR, H = canvas.height/DPR;
    const cx=W/2, cy=H/2;
    const dir = Math.atan2(pointer.y-cy, pointer.x-cx);
    const speed = rand(120,320);
    b.vx = Math.cos(dir)*speed * 0.5;
    b.vy = Math.sin(dir)*speed * 0.5;
    // trigger sound
    playPing(b.mass);
  }
});
canvas.addEventListener('pointermove', (e)=>{
  const r = canvas.getBoundingClientRect();
  const nx = (e.clientX - r.left);
  const ny = (e.clientY - r.top);
  pointer.dx = nx - pointer.x;
  pointer.dy = ny - pointer.y;
  pointer.x = nx; pointer.y = ny;
  // if dragging and picked, move body by setting velocity
  if(pointer.down && pick){
    pick.x = pointer.x;
    pick.y = pointer.y;
    pick.vx = pointer.dx * 60;
    pick.vy = pointer.dy * 60;
  }
});
canvas.addEventListener('pointerup', (e)=>{
  pointer.down = false;
  // if quick drag (launch) create impulse from drag
  if(pick){
    // small release sound
    playPing(pick.mass*0.5);
    pick = null;
  }
});
canvas.addEventListener('dblclick', ()=>{
  running = !running;
});

// picking
let pick = null;
function pickBody(x,y){
  for(let i=bodies.length-1;i>=0;i--){
    const b = bodies[i];
    const dx = x-b.x, dy = y-b.y;
    if(dx*dx+dy*dy <= b.r*b.r) return b;
  }
  return null;
}

// add button
document.getElementById('add').addEventListener('click', ()=>{
  const W = canvas.width/DPR, H = canvas.height/DPR;
  const x = rand(120, W-120), y = rand(120, H-120);
  const mass = rand(30,700);
  createBody(x,y,mass, rand(200,360));
});

// clear
document.getElementById('clear').addEventListener('click', ()=>{ bodies.length = 0; seedDemo(); });

// sound toggle
let soundOn = true;
const sndBtn = document.getElementById('sound');
sndBtn.addEventListener('click', ()=>{
  soundOn = !soundOn;
  sndBtn.textContent = soundOn ? 'üîä som: ligado' : 'üîá som: off';
  if(!soundOn) stopAudio();
});

// ---------- Audio (WebAudio) ----------
let audioCtx = null;
let masterGain = null;
let oscillator = null;
let playing = false;

function ensureAudio(){
  if(!audioCtx){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.0001;
    masterGain.connect(audioCtx.destination);
    // gentle ambient oscillator
    oscillator = audioCtx.createOscillator();
    const oscGain = audioCtx.createGain();
    oscillator.type = 'sine';
    oscillator.frequency.value = 80;
    oscGain.gain.value = 0.0008;
    oscillator.connect(oscGain);
    oscGain.connect(masterGain);
    oscillator.start();
    // periodic gentle harmonic pulses
    startAmbientPulse();
    // fade in
    fadeGainTo(0.06, 0.6);
    playing = true;
  }
}

function fadeGainTo(target, secs=0.6){
  if(!masterGain) return;
  masterGain.gain.cancelScheduledValues(audioCtx.currentTime);
  masterGain.gain.linearRampToValueAtTime(target, audioCtx.currentTime + secs);
}

function stopAudio(){
  if(!audioCtx) return;
  fadeGainTo(0.0001, 0.6);
}

function playPing(mass){
  if(!soundOn) return;
  ensureAudio();
  if(!audioCtx) return;
  const now = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = (Math.random() > 0.5) ? 'sine' : 'triangle';
  // pitch scaled by mass
  const freq = Math.min(1200, 120 + Math.sqrt(Math.max(4,mass)) * 18);
  o.frequency.value = freq;
  g.gain.value = 0.0001;
  o.connect(g);
  g.connect(masterGain);
  g.gain.linearRampToValueAtTime(0.06, now + 0.002);
  g.gain.exponentialRampToValueAtTime(0.0001, now + 0.9);
  o.start(now);
  o.stop(now + 1.0);
}

// ambient pulses (subtle)
function startAmbientPulse(){
  if(!audioCtx) return;
  const t = audioCtx.currentTime;
  // small sweep on main oscillator
  oscillator.frequency.cancelScheduledValues(t);
  const low = 28 + Math.random()*12;
  const high = 60 + Math.random()*40;
  oscillator.frequency.setValueAtTime(low, t);
  oscillator.frequency.linearRampToValueAtTime(high, t + 4 + Math.random()*6);
  oscillator.frequency.linearRampToValueAtTime(low, t + 10 + Math.random()*8);
  // schedule next
  setTimeout(()=>{ if(playing) startAmbientPulse(); }, 8000 + Math.random()*8000);
}

// ---------- Visual helpers ----------
let lastTime = performance.now();
function frame(now){
  const dt = Math.min(0.033, (now - lastTime)/1000);
  lastTime = now;
  // physics
  step(dt);
  // audio reactive: adjust ambient frequency based on total kinetic energy
  if(soundOn && audioCtx && masterGain){
    const ke = bodies.reduce((s,b)=> s + 0.5*b.mass*(b.vx*b.vx + b.vy*b.vy), 0);
    const target = clamp01(Math.log10(1 + ke) / 4);
    // modulate oscillator frequency
    oscillator.frequency.setTargetAtTime(40 + target*260, audioCtx.currentTime, 0.3);
    // modulate master gain slightly
    fadeGainTo(0.02 + target*0.08, 0.18);
  }

  render();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

// clamp helper
function clamp01(v){ return Math.max(0, Math.min(1, v)); }

// ---------- Utilities + initial settings ----------
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// initial auto-play audio only if user interacts
window.addEventListener('pointerdown', function firstTouch(){
  if(soundOn) ensureAudio();
  window.removeEventListener('pointerdown', firstTouch);
}, {passive:true});

// small responsive star regen on resize
window.addEventListener('resize', ()=>{ makeStars(canvas.width/DPR, canvas.height/DPR); });

// helper: create orbit demonstration on long press
let longPressTimer = null;
canvas.addEventListener('pointerdown', (e)=>{
  longPressTimer = setTimeout(()=>{
    // create pair to show slingshot
    const W = canvas.width/DPR, H = canvas.height/DPR;
    const x = pointer.x, y = pointer.y;
    const big = createBody(W*0.5, H*0.5, rand(1800,4200), rand(280,360));
    const small = createBody(x,y, rand(40,120), rand(200,360));
    // put small in orbit
    const dx = small.x - big.x, dy = small.y - big.y;
    const dist = Math.sqrt(dx*dx+dy*dy);
    const speed = Math.sqrt(G * big.mass / Math.max(10, dist));
    const dir = Math.atan2(dy,dx) - Math.PI/2;
    small.vx = Math.cos(dir)*speed*1.02;
    small.vy = Math.sin(dir)*speed*1.02;
    playPing(small.mass);
  }, 650);
});
canvas.addEventListener('pointerup', ()=>{ clearTimeout(longPressTimer); });

// initial visual tweak
makeStars(canvas.width/DPR, canvas.height/DPR);

// small UI polish: animate hint blink
(function animateUI(){
  const hint = document.querySelector('.hint');
  let op = 1; let d = -0.008;
  function u(){
    op += d;
    if(op <= 0.6 || op >= 1) d *= -1;
    hint.style.opacity = 0.6 + (op-0.6)*0.8;
    requestAnimationFrame(u);
  }
  u();
})();

</script>
</body>
</html>
