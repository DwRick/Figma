<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Impressionante Simples</title>
<style>
  :root{
    --bg1:#06040a;
    --bg2:#081028;
  }
  html,body{height:100%;margin:0;background:linear-gradient(135deg,var(--bg1),var(--bg2));font-family:Inter,system-ui,Arial;color:#fff;overflow:hidden}
  .wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center}
  canvas{display:block;width:100vw;height:100vh}
  .ui{
    position:fixed;left:18px;top:18px;background:rgba(255,255,255,0.04);backdrop-filter:blur(6px);padding:8px 12px;border-radius:10px;font-weight:600;font-size:13px;
    box-shadow:0 8px 30px rgba(0,0,0,0.5);
  }
  .hint{position:fixed;right:18px;bottom:18px;background:rgba(255,255,255,0.03);padding:8px 10px;border-radius:10px;font-size:13px}
  @media (max-width:520px){ .ui,.hint{font-size:12px;padding:6px 8px} }
</style>
</head>
<body>
  <div class="wrap">
    <canvas id="c"></canvas>
    <div class="ui">Toque / Clique / Arraste</div>
    <div class="hint">Clique para explodir â€¢ Segure para atrair</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });
  let DPR = Math.min(2, devicePixelRatio || 1);

  function resize(){
    DPR = Math.min(2, devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * DPR);
    canvas.height = Math.floor(rect.height * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  // make canvas fill viewport
  function fillToViewport(){
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    resize();
  }
  window.addEventListener('resize', fillToViewport, {passive:true});
  fillToViewport();

  const TAU = Math.PI*2;
  const particles = [];
  const maxParticles = 900;

  function rand(a,b){ return a + Math.random()*(b-a); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  class P {
    constructor(x,y,vx,vy,size,hue,life,blend='lighter'){
      this.x = x; this.y = y;
      this.vx = vx; this.vy = vy;
      this.size = size; this.h = hue; this.life = life; this.maxLife = life;
      this.blend = blend;
    }
    update(dt){
      this.vx *= 0.995;
      this.vy *= 0.995;
      this.vy += 40 * dt; // subtle gravity
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      this.life -= dt;
      this.size *= (1 - 0.12*dt);
    }
    draw(ctx){
      const a = clamp(this.life/this.maxLife,0,1);
      ctx.save();
      ctx.globalCompositeOperation = this.blend;
      const g = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, Math.max(2,this.size*6));
      g.addColorStop(0, `hsla(${this.h},95%,65%,${0.9*a})`);
      g.addColorStop(0.55, `hsla(${(this.h+30)%360},95%,45%,${0.28*a})`);
      g.addColorStop(1, `rgba(0,0,0,0)`);
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(this.x, this.y, Math.max(0.6,this.size), 0, TAU);
      ctx.fill();
      ctx.restore();
    }
  }

  // background gradient + moving orbs
  let bigOrbs = [];
  function makeOrbs(){
    bigOrbs = [];
    const W = canvas.width / DPR, H = canvas.height / DPR;
    for(let i=0;i<6;i++){
      bigOrbs.push({
        x: rand(0,W),
        y: rand(0,H),
        r: rand(Math.min(W,H)*0.06, Math.min(W,H)*0.16),
        h: rand(220,320),
        ang: rand(0,Math.PI*2),
        speed: rand(0.02,0.06)
      });
    }
  }
  makeOrbs();

  // interaction
  const pointer = {x:0,y:0,down:false,downAt:0,dragX:0,dragY:0};
  canvas.addEventListener('pointerdown', (e)=>{
    const r = canvas.getBoundingClientRect();
    pointer.x = e.clientX - r.left;
    pointer.y = e.clientY - r.top;
    pointer.down = true;
    pointer.downAt = performance.now();
    pointer.dragX = pointer.dragY = 0;
    // small direct burst
    burst(pointer.x, pointer.y, 28, rand(260,340));
  });
  canvas.addEventListener('pointermove', (e)=>{
    const r = canvas.getBoundingClientRect();
    const nx = e.clientX - r.left;
    const ny = e.clientY - r.top;
    pointer.dragX = nx - pointer.x;
    pointer.dragY = ny - pointer.y;
    pointer.x = nx; pointer.y = ny;
    // trailing particles while dragging
    if(pointer.down){
      for(let i=0;i<2;i++){
        pushParticle(pointer.x + rand(-6,6), pointer.y + rand(-6,6),
                     pointer.dragX*8 + rand(-40,40), pointer.dragY*8 + rand(-40,40),
                     rand(2,8), rand(300,380), rand(0.4,1.2));
      }
    }
  }, {passive:true});
  canvas.addEventListener('pointerup', (e)=>{
    pointer.down = false;
    // if it was a quick click -> big bloom
    const dt = performance.now() - pointer.downAt;
    if(dt < 220) bigBloom(pointer.x, pointer.y);
  });

  // touch fallback: prevent scrolling on touch hold drag
  canvas.addEventListener('touchstart', e=>e.preventDefault(), {passive:false});

  function pushParticle(x,y,vx,vy,size,hue,life){
    if(particles.length > maxParticles) particles.shift();
    particles.push(new P(x,y,vx,vy,size,hue,life));
  }

  function burst(x,y,count=30,hue=320){
    for(let i=0;i<count;i++){
      const ang = rand(0,TAU);
      const sp = rand(120,520);
      pushParticle(x, y, Math.cos(ang)*sp, Math.sin(ang)*sp, rand(3,12), hue + rand(-30,40), rand(0.8,1.6));
    }
  }

  function bigBloom(x,y){
    // layered bloom
    for(let k=0;k<4;k++){
      burst(x,y, 80 - k*18, 260 + k*24);
    }
  }

  // ambient soft generators
  let ambientTimer = 0;
  function ambientSpawn(dt){
    ambientTimer += dt;
    if(ambientTimer > 0.09){
      ambientTimer = 0;
      // spawn along invisible ring around center
      const W = canvas.width/DPR, H = canvas.height/DPR;
      const cx = W*0.5, cy = H*0.5;
      const r = Math.min(W,H)*0.36;
      const ang = Math.random()*TAU;
      const x = cx + Math.cos(ang)*r + rand(-20,20);
      const y = cy + Math.sin(ang)*r + rand(-20,20);
      pushParticle(x,y, rand(-20,20), rand(-20,20), rand(1.2,6), rand(260,330), rand(0.9,1.6));
    }
  }

  // main loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  function update(dt){
    // move big orbs slowly
    const W = canvas.width / DPR, H = canvas.height / DPR;
    for(const o of bigOrbs){
      o.ang += o.speed * dt * 60 * (0.06 + Math.sin(last*0.001)*0.01);
      o.x += Math.cos(o.ang)*0.12;
      o.y += Math.sin(o.ang)*0.08;
    }
    ambientSpawn(dt);
    // pointer attraction when hold
    if(pointer.down){
      for(let i=particles.length-1;i>=0;i--){
        const p = particles[i];
        const dx = pointer.x - p.x, dy = pointer.y - p.y;
        const d2 = dx*dx + dy*dy;
        if(d2 < 220*220){
          const d = Math.sqrt(d2) + 0.0001;
          const pull = (1 - clamp(d/220,0,1)) * 420;
          p.vx += (dx/d) * pull * dt;
          p.vy += (dy/d) * pull * dt;
        }
      }
    }

    // update particles
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.update(dt);
      if(p.life <= 0 || p.size < 0.6) particles.splice(i,1);
    }
  }

  function draw(){
    const W = canvas.width / DPR, H = canvas.height / DPR;
    // background base
    ctx.clearRect(0,0,W,H);
    // subtle radial vignette
    const rg = ctx.createRadialGradient(W*0.5,H*0.45, Math.min(W,H)*0.02, W*0.5,H*0.45, Math.max(W,H));
    rg.addColorStop(0, 'rgba(18,14,34,0.35)');
    rg.addColorStop(1, 'rgba(2,2,6,0.86)');
    ctx.fillStyle = rg;
    ctx.fillRect(0,0,W,H);

    // moving orbs as soft background shapes
    for(const o of bigOrbs){
      const g = ctx.createRadialGradient(o.x,o.y, o.r*0.08, o.x,o.y,o.r*1.2);
      g.addColorStop(0, `hsla(${o.h},90%,65%,0.14)`);
      g.addColorStop(0.5, `hsla(${(o.h+30)%360},90%,48%,0.08)`);
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.ellipse(o.x, o.y, o.r*1.2, o.r, 0, 0, TAU);
      ctx.fill();
    }

    // glow ring at center
    const cx = W*0.5, cy = H*0.5;
    const ring = Math.min(W,H)*0.22;
    const rg2 = ctx.createRadialGradient(cx,cy,ring*0.2,cx,cy,ring*1.4);
    rg2.addColorStop(0, 'rgba(255,255,255,0.02)');
    rg2.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = rg2;
    ctx.beginPath();
    ctx.arc(cx,cy,ring*1.4,0,TAU);
    ctx.fill();

    // particles (draw in additive manner)
    for(const p of particles){
      p.draw(ctx);
    }

    // subtle center symbol (no explanation, just pretty)
    ctx.save();
    ctx.translate(cx,cy);
    const t = performance.now() * 0.0012;
    ctx.rotate(Math.sin(t)*0.03);
    // rings
    for(let i=0;i<3;i++){
      ctx.beginPath();
      ctx.arc(0,0, 28 + i*18 + Math.sin(t*1.3 + i)*6, 0, TAU);
      ctx.strokeStyle = `hsla(${260 + i*28},90%,60%,${0.06 + i*0.02})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    // core glyph
    ctx.beginPath();
    ctx.moveTo(-10,0);
    ctx.quadraticCurveTo(0,-20,10,0);
    ctx.quadraticCurveTo(0,14,-10,0);
    ctx.closePath();
    ctx.fillStyle = 'rgba(255,255,255,0.04)';
    ctx.fill();
    ctx.restore();
  }

  // initial gentle startup bursts
  const W = canvas.width/DPR, H = canvas.height/DPR;
  for(let i=0;i<3;i++){
    bigBloom(W*0.5 + rand(-40,40), H*0.5 + rand(-40,40));
  }

  // makeOrbs on larger resize
  window.addEventListener('resize', ()=>{ makeOrbs(); });

  // start
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
